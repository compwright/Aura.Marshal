<?php

namespace Aura\Marshal;

use Aura\Marshal\Collection\Builder as CollectionBuilder;
use Aura\Marshal\Entity\Builder as EntityBuilder;
use Aura\Marshal\Entity\GenericEntity;
use Aura\Marshal\Lazy\Builder as LazyBuilder;
use Aura\Marshal\Relation\Builder as RelationBuilder;
use Aura\Marshal\Type\Builder as TypeBuilder;
use Aura\Marshal\Type\GenericType;
use Yoast\PHPUnitPolyfills\TestCases\TestCase;

/**
 * Test class for Type.
 * Generated by PHPUnit on 2011-11-21 at 18:02:55.
 */
class TypeTest extends TestCase
{
    /**
     * @var GenericType
     */
    protected $type;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function set_up(): void
    {
        parent::set_up();

        $types = include __DIR__ . DIRECTORY_SEPARATOR . 'fixture_types.php';
        $info = $types['posts'];

        $this->type = new GenericType;
        $this->type->setIdentityField($info['identity_field']);
        $this->type->setIndexFields($info['index_fields']);
        $this->type->setEntityBuilder(new EntityBuilder);
        $this->type->setCollectionBuilder(new CollectionBuilder);
    }

    /**
     * @return array<array<string, mixed>>
     */
    protected function loadTypeWithPosts()
    {
        $data = include __DIR__ . DIRECTORY_SEPARATOR . 'fixture_data.php';
        $this->type->load($data['posts']);
        return $data['posts'];
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tear_down(): void
    {
        parent::tear_down();
    }

    public function testSetAndGetIdentityField(): void
    {
        $expect = 'foobar';
        $this->type->setIdentityField('foobar');
        $actual = $this->type->getIdentityField();
        $this->assertSame($expect, $actual);
    }

    public function testSetAndGetIndexFields(): void
    {
        $expect = ['foobar', 'bazdib'];
        $this->type->setIndexFields($expect);
        $actual = $this->type->getIndexFields();
        $this->assertSame($expect, $actual);

    }
    public function testSetAndGetEntityBuilder(): void
    {
        $builder = new EntityBuilder;
        $this->type->setEntityBuilder($builder);
        $actual = $this->type->getEntityBuilder();
        $this->assertSame($builder, $actual);
    }

    public function testSetAndGetCollectionBuilder(): void
    {
        $builder = new CollectionBuilder;
        $this->type->setCollectionBuilder($builder);
        $actual = $this->type->getCollectionBuilder();
        $this->assertSame($builder, $actual);
    }

    public function testSetAndGetLazyBuilder(): void
    {
        $builder = new LazyBuilder;
        $this->type->setLazyBuilder($builder);
        $actual = $this->type->getLazyBuilder();
        $this->assertSame($builder, $actual);
    }

    public function testLoadAndGetStorage(): void
    {
        $data = $this->loadTypeWithPosts();
        $expect = count($data);
        $actual = count($this->type);
        $this->assertSame($expect, $actual);

        // try loading again to make sure we don't double-load.
        // $expect stays as the original count value.
        $this->loadTypeWithPosts();
        $actual = count($this->type);
        $this->assertSame($expect, $actual);
    }

    public function testGetIdentityValues(): void
    {
        $data = $this->loadTypeWithPosts();
        $expect = [1, 2, 3, 4, 5];
        $actual = $this->type->getIdentityValues();
        $this->assertSame($expect, $actual);
    }

    public function testGetFieldValues(): void
    {
        $data = $this->loadTypeWithPosts();
        $expect = [1 => '1', 2 => '1', 3 => '1', 4 => '2', 5 => '2'];
        $actual = $this->type->getFieldValues('author_id');
        $this->assertSame($expect, $actual);
    }

    public function testGetEntity(): void
    {
        $data = $this->loadTypeWithPosts();
        $expect = (object) $data[2];

        /**
         * @var GenericEntity $actual
         */
        $actual = $this->type->getEntity(3);

        $this->assertSame($expect->id, $actual->id);
        $this->assertSame($expect->author_id, $actual->author_id);
        $this->assertSame($expect->body, $actual->body);

        // get it again for complete code coverage
        $again = $this->type->getEntity(3);
        $this->assertSame($actual, $again);
    }

    public function testGetEntity_none(): void
    {
        $data = $this->loadTypeWithPosts();
        $actual = $this->type->getEntity(999);
        $this->assertNull($actual);
    }

    public function testGetEntityByField_identity(): void
    {
        $data = $this->loadTypeWithPosts();
        $expect = (object) $data[3];

        /**
         * @var GenericEntity $actual
         */
        $actual = $this->type->getEntityByField('id', 4);

        $this->assertSame($expect->id, $actual->id);
        $this->assertSame($expect->author_id, $actual->author_id);
        $this->assertSame($expect->body, $actual->body);
    }

    public function testGetEntityByField_index(): void
    {
        $data = $this->loadTypeWithPosts();
        $expect = (object) $data[3];

        /**
         * @var GenericEntity $actual
         */
        $actual = $this->type->getEntityByField('author_id', 2);

        $this->assertSame($expect->id, $actual->id);
        $this->assertSame($expect->author_id, $actual->author_id);
        $this->assertSame($expect->body, $actual->body);
    }

    public function testGetEntityByField_indexNone(): void
    {
        $this->loadTypeWithPosts();
        $actual = $this->type->getEntityByField('author_id', 'no such value');
        $this->assertNull($actual);
    }

    public function testGetEntityByField_loop(): void
    {
        $data = $this->loadTypeWithPosts();
        $expect = (object) $data[3];

        /**
         * @var GenericEntity $actual
         */
        $actual = $this->type->getEntityByField('fake_field', '88');

        $this->assertSame($expect->id, $actual->id);
        $this->assertSame($expect->author_id, $actual->author_id);
        $this->assertSame($expect->body, $actual->body);
        $this->assertSame($expect->fake_field, $actual->fake_field);
    }

    public function testGetEntityByField_loopNone(): void
    {
        $data = $this->loadTypeWithPosts();
        $actual = $this->type->getEntityByField('fake_field', 'no such value');
        $this->assertNull($actual);
    }

    public function testGetCollection(): void
    {
        $data = $this->loadTypeWithPosts();
        $collection = $this->type->getCollection([1, 2, 3]);
        $expect = [
            (object) $data[0],
            (object) $data[1],
            (object) $data[2],
        ];

        foreach ($collection as $offset => $actual) {
            $this->assertSame($expect[$offset]->id, $actual->id);
            $this->assertSame($expect[$offset]->author_id, $actual->author_id);
            $this->assertSame($expect[$offset]->body, $actual->body);
        }
    }

    public function testGetCollectionByField(): void
    {
        $data = $this->loadTypeWithPosts();
        $collection = $this->type->getCollectionByField('fake_field', 88);
        $expect = [
            (object) $data[3],
            (object) $data[4],
        ];

        foreach ($collection as $offset => $actual) {
            $this->assertSame($expect[$offset]->id, $actual->id);
            $this->assertSame($expect[$offset]->author_id, $actual->author_id);
            $this->assertSame($expect[$offset]->body, $actual->body);
            $this->assertSame($expect[$offset]->fake_field, $actual->fake_field);
        }
    }

    public function testGetCollectionByField_many(): void
    {
        $data = $this->loadTypeWithPosts();
        $collection = $this->type->getCollectionByField('fake_field', [88, 69]);
        $expect = [
            (object) $data[0],
            (object) $data[1],
            (object) $data[2],
            (object) $data[3],
            (object) $data[4],
        ];

        foreach ($collection as $offset => $actual) {
            $this->assertSame($expect[$offset]->id, $actual->id);
            $this->assertSame($expect[$offset]->author_id, $actual->author_id);
            $this->assertSame($expect[$offset]->body, $actual->body);
            $this->assertSame($expect[$offset]->fake_field, $actual->fake_field);
        }
    }

    public function testGetCollectionByField_identity(): void
    {
        $data = $this->loadTypeWithPosts();
        $collection = $this->type->getCollectionByField('id', [4, 5]);
        $expect = [
            (object) $data[3],
            (object) $data[4],
        ];

        foreach ($collection as $offset => $actual) {
            $this->assertSame($expect[$offset]->id, $actual->id);
            $this->assertSame($expect[$offset]->author_id, $actual->author_id);
            $this->assertSame($expect[$offset]->body, $actual->body);
            $this->assertSame($expect[$offset]->fake_field, $actual->fake_field);
        }
    }

    public function testGetCollectionByField_index(): void
    {
        $data = $this->loadTypeWithPosts();
        $collection = $this->type->getCollectionByField('author_id', [2, 1]);
        $expect = [
            (object) $data[3],
            (object) $data[4],
            (object) $data[0],
            (object) $data[1],
            (object) $data[2],
        ];

        foreach ($collection as $offset => $actual) {
            $this->assertSame($expect[$offset]->id, $actual->id);
            $this->assertSame($expect[$offset]->author_id, $actual->author_id);
            $this->assertSame($expect[$offset]->body, $actual->body);
            $this->assertSame($expect[$offset]->fake_field, $actual->fake_field);
        }
    }

    public function testAddAndGetRelation(): void
    {
        $type_builder = new TypeBuilder;
        $relation_builder = new RelationBuilder;
        $types = include __DIR__ . DIRECTORY_SEPARATOR . 'fixture_types.php';
        $manager = new Manager($type_builder, $relation_builder, $types);

        $name = 'meta';
        $info = $types['posts']['relation_names'][$name];

        $relation = $relation_builder->newInstance('posts', $name, $info, $manager);
        $this->type->setRelation($name, $relation);

        $actual = $this->type->getRelation('meta');
        $this->assertSame($relation, $actual);

        // try again again, should fail
        $this->expectException('Aura\Marshal\Exception');
        $this->type->setRelation($name, $relation);
    }

    public function testTypeBuilder_noIdentityField(): void
    {
        $type_builder = new TypeBuilder;
        $this->expectException('Aura\Marshal\Exception');
        $type = $type_builder->newInstance([]);
    }

    public function testNewEntity(): void
    {
        $this->loadTypeWithPosts();
        $before = count($this->type);

        // do we actually get a new entity back?
        $entity = $this->type->newEntity();
        $this->assertInstanceOf('Aura\Marshal\Entity\GenericEntity', $entity);

        // has it been added to the identity map?
        $expect = $before + 1;
        $actual = count($this->type);
        $this->assertSame($expect, $actual);
    }

    public function testGetChangedEntities(): void
    {
        $this->loadTypeWithPosts();

        /**
         * Change entity id 1 and 3
         * 
         * @var GenericEntity $entity_1
         */
        $entity_1 = $this->type->getEntity(1);
        $entity_1->fake_field = 'changed';

        /**
         * @var GenericEntity $entity_3
         */
        $entity_3 = $this->type->getEntity(3);
        $entity_3->fake_field = 'changed';

        /**
         * Get entity 2 but don't change it
         * 
         * @var GenericEntity $entity_2
         */
        $entity_2 = $this->type->getEntity(2);
        $fake_field = $entity_2->fake_field;
        $entity_2->fake_field = $fake_field;

        // now check for changes
        $expect = [
            $entity_1->id => $entity_1,
            $entity_3->id => $entity_3,
        ];

        $actual = $this->type->getChangedEntities();
        $this->assertSame($expect, $actual);
    }

    public function testGetChangedEntities_empty(): void
    {
        $data = $this->loadTypeWithPosts();
        $expect = [];

        $actual = $this->type->getChangedEntities();
        $this->assertSame($expect, $actual);
    }

    public function testGetNewEntities(): void
    {
        $data = $this->loadTypeWithPosts();
        $expect = [
            $this->type->newEntity(['fake_field' => 101]),
            $this->type->newEntity(['fake_field' => 102]),
            $this->type->newEntity(['fake_field' => 105]),
        ];
        $actual = $this->type->getNewEntities();
        $this->assertSame($expect, $actual);
    }

    public function testGetNewEntities_empty(): void
    {
        $data = $this->loadTypeWithPosts();
        $expect = [];
        $actual = $this->type->getNewEntities();
        $this->assertSame($expect, $actual);
    }

    public function testGetInitialData_noEntity(): void
    {
        $entity = new GenericEntity([]);
        $this->assertNull($this->type->getInitialData($entity));
    }

    public function testGetChangedFields_numeric(): void
    {
        $this->loadTypeWithPosts();

        /**
         * @var GenericEntity $entity
         */
        $entity = $this->type->getEntity(1);

        // change from string '69' to int 69;
        // it should not be marked as a change
        $entity->fake_field = 69;
        $expect = [];
        $actual = $this->type->getChangedFields($entity);
        $this->assertSame($expect, $actual);

        $entity->fake_field = 4.56;
        $expect = ['fake_field' => 4.56];
        $actual = $this->type->getChangedFields($entity);
        $this->assertSame($expect, $actual);
    }

    public function testGetChangedFields_toNull(): void
    {
        $this->loadTypeWithPosts();

        /**
         * @var GenericEntity $entity
         */
        $entity = $this->type->getEntity(1);

        $entity->fake_field = null;
        $expect = ['fake_field' => null];
        $actual = $this->type->getChangedFields($entity);
        $this->assertSame($expect, $actual);
    }

    public function testGetChangedFields_fromNull(): void
    {
        $this->loadTypeWithPosts();

        /**
         * @var GenericEntity $entity
         */
        $entity = $this->type->getEntity(1);

        $entity->null_field = 0;
        $expect = ['null_field' => 0];
        $actual = $this->type->getChangedFields($entity);
        $this->assertSame($expect, $actual);
    }

    public function testGetChangedFields_other(): void
    {
        $this->loadTypeWithPosts();

        /**
         * @var GenericEntity $entity
         */
        $entity = $this->type->getEntity(1);

        $entity->fake_field = 'changed';
        $expect = ['fake_field' => 'changed'];
        $actual = $this->type->getChangedFields($entity);
        $this->assertSame($expect, $actual);
    }

    public function testLoadEntity(): void
    {
        $initial_data = [
            'id'  => 88,
            'author_id' => 69,
            'foo' => 'bar',
            'baz' => 'dib',
            'zim' => 'gir',
        ];

        /**
         * @var GenericEntity $entity
         */
        $entity = $this->type->loadEntity($initial_data);

        foreach ($initial_data as $field => $value) {
            $this->assertSame($value, $entity->$field);
        }
    }

    public function testLoadCollection(): void
    {
        $data = include __DIR__ . DIRECTORY_SEPARATOR . 'fixture_data.php';
        $collection = $this->type->loadCollection($data['posts']);
        $this->assertInstanceOf(
            'Aura\Marshal\Collection\GenericCollection',
            $collection
        );
    }

    public function testRemove_none(): void
    {
        $this->loadTypeWithPosts();

        $this->assertSame([], $this->type->getRemovedEntities());
    }

    public function testRemove_single(): void
    {
        $this->loadTypeWithPosts();

        $this->assertTrue($this->type->removeEntity(1));

        $this->assertSame([1], array_keys($this->type->getRemovedEntities()));
    }

    public function testRemove_many(): void
    {
        $this->loadTypeWithPosts();

        $this->assertTrue($this->type->removeEntity(1));
        $this->assertTrue($this->type->removeEntity(2));
        $this->assertTrue($this->type->removeEntity(3));

        $this->assertSame(
            [1, 2, 3],
            array_keys($this->type->getRemovedEntities())
        );
    }

    public function testRemoveNonExistent(): void
    {
        $this->loadTypeWithPosts();

        $this->assertFalse($this->type->removeEntity(99999));
    }

    public function testRemoveAndGet(): void
    {
        $this->loadTypeWithPosts();
        $this->assertTrue($this->type->removeEntity(1));

        $this->assertNull($this->type->getEntity(1));
    }

    public function testRemoveAndDeleteAgain(): void
    {
        $this->loadTypeWithPosts();
        $this->assertTrue($this->type->removeEntity(1));
        $this->assertFalse($this->type->removeEntity(1));
    }

    public function testRemoveEmpty(): void
    {
        $this->assertFalse($this->type->removeEntity(1));
    }

    public function testRemoveAndGetCollectionByIndex_first(): void
    {
        $data = $this->loadTypeWithPosts();

        $expect = [
            (object) $data[1],
            (object) $data[2]
        ];

        $this->assertTrue($this->type->removeEntity(1));

        $collection = $this->type->getCollectionByField('author_id', 1);

        foreach ($collection as $offset => $actual) {
            $this->assertSame($expect[$offset]->id, $actual->id);
            $this->assertSame($expect[$offset]->author_id, $actual->author_id);
            $this->assertSame($expect[$offset]->body, $actual->body);
            $this->assertSame($expect[$offset]->fake_field, $actual->fake_field);
        }
    }

    public function testRemoveAndGetCollectionByIndex_second(): void
    {
        $data = $this->loadTypeWithPosts();

        $expect = [
            (object) $data[0],
            (object) $data[2]
        ];

        $this->assertTrue($this->type->removeEntity(2));

        $collection = $this->type->getCollectionByField('author_id', 1);

        foreach ($collection as $offset => $actual) {
            $this->assertSame($expect[$offset]->id, $actual->id);
            $this->assertSame($expect[$offset]->author_id, $actual->author_id);
            $this->assertSame($expect[$offset]->body, $actual->body);
            $this->assertSame($expect[$offset]->fake_field, $actual->fake_field);
        }
    }

    public function testRemoveAndGetCollectionByField_first(): void
    {
        $data = $this->loadTypeWithPosts();

        $expect = [
            (object) $data[4]
        ];

        $this->assertTrue($this->type->removeEntity(4));

        $collection = $this->type->getCollectionByField('fake_field', 88);

        foreach ($collection as $offset => $actual) {
            $this->assertSame($expect[$offset]->id, $actual->id);
            $this->assertSame($expect[$offset]->author_id, $actual->author_id);
            $this->assertSame($expect[$offset]->body, $actual->body);
            $this->assertSame($expect[$offset]->fake_field, $actual->fake_field);
        }
    }

    public function testRemoveAndGetCollectionByField_second(): void
    {
        $data = $this->loadTypeWithPosts();

        $expect = [
            (object) $data[0],
            (object) $data[2],
        ];

        $this->assertTrue($this->type->removeEntity(2));

        $collection = $this->type->getCollectionByField('fake_field', 69);

        foreach ($collection as $offset => $actual) {
            $this->assertSame($expect[$offset]->id, $actual->id);
            $this->assertSame($expect[$offset]->author_id, $actual->author_id);
            $this->assertSame($expect[$offset]->body, $actual->body);
            $this->assertSame($expect[$offset]->fake_field, $actual->fake_field);
        }
    }

    public function testRemoveAndGetCollectionByField_many(): void
    {
        $data = $this->loadTypeWithPosts();

        $expect = [
            (object) $data[0],
            (object) $data[2],
            (object) $data[4]
        ];

        $this->assertTrue($this->type->removeEntity(2));
        $this->assertTrue($this->type->removeEntity(4));

        $collection = $this->type->getCollectionByField('fake_field', [88, 69]);

        foreach ($collection as $offset => $actual) {
            $this->assertSame($expect[$offset]->id, $actual->id);
            $this->assertSame($expect[$offset]->author_id, $actual->author_id);
            $this->assertSame($expect[$offset]->body, $actual->body);
            $this->assertSame($expect[$offset]->fake_field, $actual->fake_field);
        }
    }

    public function testRemoveAll(): void
    {
        $data = $this->loadTypeWithPosts();

        foreach ($data as $post) {
            $this->assertTrue($this->type->removeEntity($post['id']));
        }

        $this->assertSame(0, $this->type->count());

        $this->assertNull($this->type->getEntity(1));
    }

    public function testClear(): void
    {
        $data = $this->loadTypeWithPosts();

        // remove three entities so we can check if removed gets cleared
        for ($i = 0; $i < 3; $i++) {
            $post = $data[$i];
            $this->assertTrue($this->type->removeEntity($post['id']));
        }

        // now clear it and make sure we have nothing
        $this->type->clear();
        $this->assertSame([], $this->type->getAllEntities());
        $this->assertSame([], $this->type->getRemovedEntities());
    }
}
